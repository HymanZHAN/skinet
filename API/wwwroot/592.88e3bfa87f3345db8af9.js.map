{"version":3,"sources":["./node_modules/@ngneat/until-destroy/__ivy_ngcc__/fesm2015/ngneat-until-destroy.js","./src/app/shared/models/delivery-method.model.ts","./src/app/shared/models/address.model.ts","./src/app/checkout/checkout.service.ts"],"names":["NG_PIPE_DEF","DESTROY","Symbol","DECORATOR_APPLIED","getSymbol","destroyMethodName","createSubjectOnTheInstance","instance","symbol","completeSubjectOnTheInstance","next","complete","unsubscribe","property","decorateNgOnDestroy","ngOnDestroy","options","_a","call","this","arrayName","Array","isArray","forEach","checkProperties","blackList","includes","UntilDestroy","type","def","ɵpipe","onDestroy","decoratePipe","prototype","decorateProviderDirectiveOrComponent","markAsDecorated","untilDestroyed","source","originalDestroy","apply","arguments","overrideNonDirectiveInstanceMethod","pipe","EMPTY_DELIVERY_METHOD","id","shortName","deliveryTime","description","price","EMPTY_ADDRESS","firstName","lastName","street","city","state","zipCode","CheckoutService","http","basketService","baseUrl","environment","deliveryMethods","BehaviorSubject","deliveryMethods$","asObservable","deliveryMethod","deliveryMethod$","shippingAddress","shippingAddress$","basket$","orderSubtotal$","map","basket","calculateOrderSubtotal","orderShippingFee$","orderTotal$","combineLatest","obs","orderSummary$","orderSubtotal","orderShippingFee","orderTotal","get","methods","sort","a","b","methodId","nextMethod","value","find","m","toString","currentBasket","deliveryMethodId","setBasket","address","orderToCreate","basketId","shipToAddress","subscribe","order","generateOrderToCreate","post","items","length","item","quantity","reduce","createPaymentIntent"],"mappings":"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","file":"592.88e3bfa87f3345db8af9.js","sourcesContent":["import { ɵNG_PIPE_DEF } from '@angular/core';\nimport { Subject } from 'rxjs';\nimport { takeUntil } from 'rxjs/operators';\n\nconst NG_PIPE_DEF = ɵNG_PIPE_DEF;\nfunction isPipe(target) {\n    return !!target[NG_PIPE_DEF];\n}\n\nfunction isFunction(target) {\n    return typeof target === 'function';\n}\n/**\n * Applied to instances and stores `Subject` instance when\n * no custom destroy method is provided.\n */\nconst DESTROY = Symbol('__destroy');\n/**\n * Applied to definitions and informs that class is decorated\n */\nconst DECORATOR_APPLIED = Symbol('__decoratorApplied');\n/**\n * If we use the `untilDestroyed` operator multiple times inside the single\n * instance providing different `destroyMethodName`, then all streams will\n * subscribe to the single subject. If any method is invoked, the subject will\n * emit and all streams will be unsubscribed. We wan't to prevent this behavior,\n * thus we store subjects under different symbols.\n */\nfunction getSymbol(destroyMethodName) {\n    if (typeof destroyMethodName === 'string') {\n        return Symbol(`__destroy__${destroyMethodName}`);\n    }\n    else {\n        return DESTROY;\n    }\n}\nfunction markAsDecorated(type) {\n    // Store this property on the prototype if it's an injectable class, component or directive.\n    // We will be able to handle class extension this way.\n    type.prototype[DECORATOR_APPLIED] = true;\n}\nfunction createSubjectOnTheInstance(instance, symbol) {\n    if (!instance[symbol]) {\n        instance[symbol] = new Subject();\n    }\n}\nfunction completeSubjectOnTheInstance(instance, symbol) {\n    if (instance[symbol]) {\n        instance[symbol].next();\n        instance[symbol].complete();\n        // We also have to re-assign this property thus in the future\n        // we will be able to create new subject on the same instance.\n        instance[symbol] = null;\n    }\n}\n\nfunction unsubscribe(property) {\n    property && isFunction(property.unsubscribe) && property.unsubscribe();\n}\nfunction unsubscribeIfPropertyIsArrayLike(property) {\n    Array.isArray(property) && property.forEach(unsubscribe);\n}\nfunction decorateNgOnDestroy(ngOnDestroy, options) {\n    return function () {\n        var _a;\n        // Invoke the original `ngOnDestroy` if it exists\n        ngOnDestroy && ngOnDestroy.call(this);\n        // It's important to use `this` instead of caching instance\n        // that may lead to memory leaks\n        completeSubjectOnTheInstance(this, getSymbol());\n        // Check if subscriptions are pushed to some array\n        if (options.arrayName) {\n            return unsubscribeIfPropertyIsArrayLike(this[options.arrayName]);\n        }\n        // Loop through the properties and find subscriptions\n        if (options.checkProperties) {\n            for (const property in this) {\n                if ((_a = options.blackList) === null || _a === void 0 ? void 0 : _a.includes(property)) {\n                    continue;\n                }\n                unsubscribe(this[property]);\n            }\n        }\n    };\n}\nfunction decorateProviderDirectiveOrComponent(type, options) {\n    type.prototype.ngOnDestroy = decorateNgOnDestroy(type.prototype.ngOnDestroy, options);\n}\nfunction decoratePipe(type, options) {\n    const def = type.ɵpipe;\n    def.onDestroy = decorateNgOnDestroy(def.onDestroy, options);\n}\nfunction UntilDestroy(options = {}) {\n    return (type) => {\n        if (isPipe(type)) {\n            decoratePipe(type, options);\n        }\n        else {\n            decorateProviderDirectiveOrComponent(type, options);\n        }\n        markAsDecorated(type);\n    };\n}\n\nfunction overrideNonDirectiveInstanceMethod(instance, destroyMethodName, symbol) {\n    const originalDestroy = instance[destroyMethodName];\n    if (ngDevMode && isFunction(originalDestroy) === false) {\n        throw new Error(`${instance.constructor.name} is using untilDestroyed but doesn't implement ${destroyMethodName}`);\n    }\n    createSubjectOnTheInstance(instance, symbol);\n    instance[destroyMethodName] = function () {\n        originalDestroy.apply(this, arguments);\n        completeSubjectOnTheInstance(this, symbol);\n        // We have to re-assign this property back to the original value.\n        // If the `untilDestroyed` operator is called for the same instance\n        // multiple times, then we will be able to get the original\n        // method again and not the patched one.\n        instance[destroyMethodName] = originalDestroy;\n    };\n}\nfunction untilDestroyed(instance, destroyMethodName) {\n    return (source) => {\n        const symbol = getSymbol(destroyMethodName);\n        // If `destroyMethodName` is passed then the developer applies\n        // this operator to something non-related to Angular DI system\n        if (typeof destroyMethodName === 'string') {\n            overrideNonDirectiveInstanceMethod(instance, destroyMethodName, symbol);\n        }\n        else {\n            ngDevMode && ensureClassIsDecorated(instance);\n            createSubjectOnTheInstance(instance, symbol);\n        }\n        return source.pipe(takeUntil(instance[symbol]));\n    };\n}\nfunction ensureClassIsDecorated(instance) {\n    const prototype = Object.getPrototypeOf(instance);\n    const missingDecorator = !(DECORATOR_APPLIED in prototype);\n    if (missingDecorator) {\n        throw new Error('untilDestroyed operator cannot be used inside directives or ' +\n            'components or providers that are not decorated with UntilDestroy decorator');\n    }\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { UntilDestroy, untilDestroyed };\n\n//# sourceMappingURL=ngneat-until-destroy.js.map","export interface IDeliveryMethod {\r\n  id: number;\r\n  shortName: string;\r\n  deliveryTime: string;\r\n  description: string;\r\n  price: number;\r\n}\r\n\r\nexport const EMPTY_DELIVERY_METHOD: IDeliveryMethod = {\r\n  id: 0,\r\n  shortName: '',\r\n  deliveryTime: '',\r\n  description: '',\r\n  price: 0,\r\n};\r\n","export interface IAddress {\r\n  id: number;\r\n  firstName: string;\r\n  lastName: string;\r\n  street: string;\r\n  city: string;\r\n  state: string;\r\n  zipCode: string;\r\n}\r\n\r\nexport interface IAddressFormValue {\r\n  firstName: string;\r\n  lastName: string;\r\n  street: string;\r\n  city: string;\r\n  state: string;\r\n  zipCode: string;\r\n}\r\n\r\nexport const EMPTY_ADDRESS: IAddressFormValue = {\r\n  firstName: '',\r\n  lastName: '',\r\n  street: '',\r\n  city: '',\r\n  state: '',\r\n  zipCode: '',\r\n};\r\n","import { HttpClient } from '@angular/common/http';\r\nimport { Injectable } from '@angular/core';\r\nimport { environment } from 'src/environments/environment';\r\nimport {\r\n  EMPTY_DELIVERY_METHOD,\r\n  IDeliveryMethod,\r\n} from 'src/app/shared/models/delivery-method.model';\r\nimport { map } from 'rxjs/operators';\r\nimport { BehaviorSubject, combineLatest, Observable } from 'rxjs';\r\nimport { IOrder, IOrderSummary, IOrderToCreate } from '../shared/models/order.model';\r\nimport { BasketService } from '../basket/basket.service';\r\nimport { EMPTY_ADDRESS, IAddressFormValue } from '../shared/models/address.model';\r\nimport { IBasket } from '../shared/models/basket.model';\r\n\r\n@Injectable({\r\n  providedIn: 'root',\r\n})\r\nexport class CheckoutService {\r\n  baseUrl = environment.apiUrl;\r\n  deliveryMethods = new BehaviorSubject<IDeliveryMethod[]>([]);\r\n  deliveryMethods$ = this.deliveryMethods.asObservable();\r\n\r\n  private deliveryMethod = new BehaviorSubject<IDeliveryMethod>(EMPTY_DELIVERY_METHOD);\r\n  deliveryMethod$ = this.deliveryMethod.asObservable();\r\n\r\n  private shippingAddress = new BehaviorSubject<IAddressFormValue>(EMPTY_ADDRESS);\r\n  shippingAddress$ = this.shippingAddress.asObservable();\r\n\r\n  private basket$ = this.basketService.basket$;\r\n\r\n  private orderSubtotal$ = this.basket$.pipe(map((basket) => this.calculateOrderSubtotal(basket)));\r\n  private orderShippingFee$ = this.deliveryMethod$.pipe(\r\n    map((deliveryMethod) => deliveryMethod.price)\r\n  );\r\n  private orderTotal$ = combineLatest([this.orderSubtotal$, this.orderShippingFee$]).pipe(\r\n    map((obs) => obs[0] + obs[1])\r\n  );\r\n\r\n  orderSummary$ = combineLatest([\r\n    this.orderSubtotal$,\r\n    this.orderShippingFee$,\r\n    this.orderTotal$,\r\n  ]).pipe(\r\n    map((obs) => {\r\n      return {\r\n        orderSubtotal: obs[0],\r\n        orderShippingFee: obs[1],\r\n        orderTotal: obs[2],\r\n      } as IOrderSummary;\r\n    })\r\n  );\r\n\r\n  constructor(private http: HttpClient, private basketService: BasketService) {}\r\n\r\n  getDeliveryMethods() {\r\n    return this.http.get<IDeliveryMethod[]>(`${this.baseUrl}/orders/deliveryMethods`).pipe(\r\n      map((methods) => methods.sort((a, b) => b.price - a.price)),\r\n      map((methods) => this.deliveryMethods.next(methods))\r\n    );\r\n  }\r\n\r\n  setShippingMethod(methodId: string) {\r\n    let nextMethod = this.deliveryMethods.value.find((m) => m.id.toString() === methodId);\r\n    nextMethod = nextMethod || EMPTY_DELIVERY_METHOD;\r\n    this.deliveryMethod.next(nextMethod);\r\n\r\n    const currentBasket = this.basketService.currentBasket;\r\n    currentBasket.deliveryMethodId = nextMethod.id;\r\n    this.basketService.setBasket(currentBasket);\r\n  }\r\n\r\n  clearShippingMethod() {\r\n    this.deliveryMethod.next(EMPTY_DELIVERY_METHOD);\r\n  }\r\n\r\n  setShippingAddress(address: IAddressFormValue) {\r\n    this.shippingAddress.next(address);\r\n  }\r\n\r\n  generateOrderToCreate() {\r\n    let orderToCreate;\r\n    combineLatest([this.basket$, this.deliveryMethod$, this.shippingAddress$])\r\n      .pipe(\r\n        map((obs) => {\r\n          return {\r\n            basketId: obs[0].id,\r\n            deliveryMethodId: obs[1].id,\r\n            shipToAddress: obs[2],\r\n          } as IOrderToCreate;\r\n        })\r\n      )\r\n      .subscribe((order) => {\r\n        orderToCreate = order;\r\n      })\r\n      .unsubscribe();\r\n    return orderToCreate;\r\n  }\r\n\r\n  createOrder() {\r\n    const orderToCreate = this.generateOrderToCreate();\r\n    return this.http.post<IOrder>(`${this.baseUrl}/orders`, orderToCreate);\r\n  }\r\n\r\n  calculateOrderSubtotal(basket: IBasket) {\r\n    return basket.items.length === 0\r\n      ? 0\r\n      : basket.items.map((item) => item.quantity * item.price).reduce((a, b) => a + b);\r\n  }\r\n\r\n  createPaymentIntent() {\r\n    return this.basketService.createPaymentIntent();\r\n  }\r\n}\r\n"],"sourceRoot":"webpack:///"}